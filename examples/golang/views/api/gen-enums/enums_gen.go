// Code generated by go-enum DO NOT EDIT.
// Version: v0.9.2

// Built By: go install

package enums

import (
	"fmt"
	"strings"
)

const (
	// ColorEnumRED is a ColorEnum of type RED.
	ColorEnumRED ColorEnum = "red"
	// ColorEnumGREEN is a ColorEnum of type GREEN.
	ColorEnumGREEN ColorEnum = "green"
	// ColorEnumBLUE is a ColorEnum of type BLUE.
	ColorEnumBLUE ColorEnum = "blue"
)

var ErrInvalidColorEnum = fmt.Errorf("not a valid ColorEnum, try [%s]", strings.Join(_ColorEnumNames, ", "))

var _ColorEnumNames = []string{
	string(ColorEnumRED),
	string(ColorEnumGREEN),
	string(ColorEnumBLUE),
}

// ColorEnumNames returns a list of possible string values of ColorEnum.
func ColorEnumNames() []string {
	tmp := make([]string, len(_ColorEnumNames))
	copy(tmp, _ColorEnumNames)
	return tmp
}

// ColorEnumValues returns a list of the values for ColorEnum
func ColorEnumValues() []ColorEnum {
	return []ColorEnum{
		ColorEnumRED,
		ColorEnumGREEN,
		ColorEnumBLUE,
	}
}

// String implements the Stringer interface.
func (x ColorEnum) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ColorEnum) IsValid() bool {
	_, err := ParseColorEnum(string(x))
	return err == nil
}

var _ColorEnumValue = map[string]ColorEnum{
	"red":   ColorEnumRED,
	"green": ColorEnumGREEN,
	"blue":  ColorEnumBLUE,
}

// ParseColorEnum attempts to convert a string to a ColorEnum.
func ParseColorEnum(name string) (ColorEnum, error) {
	if x, ok := _ColorEnumValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ColorEnumValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ColorEnum(""), fmt.Errorf("%s is %w", name, ErrInvalidColorEnum)
}

// MustParseColorEnum converts a string to a ColorEnum, and panics if is not valid.
func MustParseColorEnum(name string) ColorEnum {
	val, err := ParseColorEnum(name)
	if err != nil {
		panic(err)
	}
	return val
}

// MarshalText implements the text marshaller method.
func (x ColorEnum) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ColorEnum) UnmarshalText(text []byte) error {
	tmp, err := ParseColorEnum(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *ColorEnum) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// HelloWayEnumASD is a HelloWayEnum of type ASD.
	HelloWayEnumASD HelloWayEnum = "ASD"
)

var ErrInvalidHelloWayEnum = fmt.Errorf("not a valid HelloWayEnum, try [%s]", strings.Join(_HelloWayEnumNames, ", "))

var _HelloWayEnumNames = []string{
	string(HelloWayEnumASD),
}

// HelloWayEnumNames returns a list of possible string values of HelloWayEnum.
func HelloWayEnumNames() []string {
	tmp := make([]string, len(_HelloWayEnumNames))
	copy(tmp, _HelloWayEnumNames)
	return tmp
}

// HelloWayEnumValues returns a list of the values for HelloWayEnum
func HelloWayEnumValues() []HelloWayEnum {
	return []HelloWayEnum{
		HelloWayEnumASD,
	}
}

// String implements the Stringer interface.
func (x HelloWayEnum) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x HelloWayEnum) IsValid() bool {
	_, err := ParseHelloWayEnum(string(x))
	return err == nil
}

var _HelloWayEnumValue = map[string]HelloWayEnum{
	"ASD": HelloWayEnumASD,
	"asd": HelloWayEnumASD,
}

// ParseHelloWayEnum attempts to convert a string to a HelloWayEnum.
func ParseHelloWayEnum(name string) (HelloWayEnum, error) {
	if x, ok := _HelloWayEnumValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _HelloWayEnumValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return HelloWayEnum(""), fmt.Errorf("%s is %w", name, ErrInvalidHelloWayEnum)
}

// MustParseHelloWayEnum converts a string to a HelloWayEnum, and panics if is not valid.
func MustParseHelloWayEnum(name string) HelloWayEnum {
	val, err := ParseHelloWayEnum(name)
	if err != nil {
		panic(err)
	}
	return val
}

// MarshalText implements the text marshaller method.
func (x HelloWayEnum) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *HelloWayEnum) UnmarshalText(text []byte) error {
	tmp, err := ParseHelloWayEnum(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *HelloWayEnum) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// MapEnumA is a MapEnum of type A.
	MapEnumA MapEnum = "a"
	// MapEnumB is a MapEnum of type B.
	MapEnumB MapEnum = "b"
)

var ErrInvalidMapEnum = fmt.Errorf("not a valid MapEnum, try [%s]", strings.Join(_MapEnumNames, ", "))

var _MapEnumNames = []string{
	string(MapEnumA),
	string(MapEnumB),
}

// MapEnumNames returns a list of possible string values of MapEnum.
func MapEnumNames() []string {
	tmp := make([]string, len(_MapEnumNames))
	copy(tmp, _MapEnumNames)
	return tmp
}

// MapEnumValues returns a list of the values for MapEnum
func MapEnumValues() []MapEnum {
	return []MapEnum{
		MapEnumA,
		MapEnumB,
	}
}

// String implements the Stringer interface.
func (x MapEnum) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x MapEnum) IsValid() bool {
	_, err := ParseMapEnum(string(x))
	return err == nil
}

var _MapEnumValue = map[string]MapEnum{
	"a": MapEnumA,
	"b": MapEnumB,
}

// ParseMapEnum attempts to convert a string to a MapEnum.
func ParseMapEnum(name string) (MapEnum, error) {
	if x, ok := _MapEnumValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _MapEnumValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return MapEnum(""), fmt.Errorf("%s is %w", name, ErrInvalidMapEnum)
}

// MustParseMapEnum converts a string to a MapEnum, and panics if is not valid.
func MustParseMapEnum(name string) MapEnum {
	val, err := ParseMapEnum(name)
	if err != nil {
		panic(err)
	}
	return val
}

// MarshalText implements the text marshaller method.
func (x MapEnum) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *MapEnum) UnmarshalText(text []byte) error {
	tmp, err := ParseMapEnum(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *MapEnum) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// StatusEnumPENDING is a StatusEnum of type PENDING.
	StatusEnumPENDING StatusEnum = iota + 1
	// StatusEnumRUNNING is a StatusEnum of type RUNNING.
	StatusEnumRUNNING
	// StatusEnumFINISHED is a StatusEnum of type FINISHED.
	StatusEnumFINISHED
)

var ErrInvalidStatusEnum = fmt.Errorf("not a valid StatusEnum, try [%s]", strings.Join(_StatusEnumNames, ", "))

const _StatusEnumName = "PENDINGRUNNINGFINISHED"

var _StatusEnumNames = []string{
	_StatusEnumName[0:7],
	_StatusEnumName[7:14],
	_StatusEnumName[14:22],
}

// StatusEnumNames returns a list of possible string values of StatusEnum.
func StatusEnumNames() []string {
	tmp := make([]string, len(_StatusEnumNames))
	copy(tmp, _StatusEnumNames)
	return tmp
}

// StatusEnumValues returns a list of the values for StatusEnum
func StatusEnumValues() []StatusEnum {
	return []StatusEnum{
		StatusEnumPENDING,
		StatusEnumRUNNING,
		StatusEnumFINISHED,
	}
}

var _StatusEnumMap = map[StatusEnum]string{
	StatusEnumPENDING:  _StatusEnumName[0:7],
	StatusEnumRUNNING:  _StatusEnumName[7:14],
	StatusEnumFINISHED: _StatusEnumName[14:22],
}

// String implements the Stringer interface.
func (x StatusEnum) String() string {
	if str, ok := _StatusEnumMap[x]; ok {
		return str
	}
	return fmt.Sprintf("StatusEnum(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x StatusEnum) IsValid() bool {
	_, ok := _StatusEnumMap[x]
	return ok
}

var _StatusEnumValue = map[string]StatusEnum{
	_StatusEnumName[0:7]:                    StatusEnumPENDING,
	strings.ToLower(_StatusEnumName[0:7]):   StatusEnumPENDING,
	_StatusEnumName[7:14]:                   StatusEnumRUNNING,
	strings.ToLower(_StatusEnumName[7:14]):  StatusEnumRUNNING,
	_StatusEnumName[14:22]:                  StatusEnumFINISHED,
	strings.ToLower(_StatusEnumName[14:22]): StatusEnumFINISHED,
}

// ParseStatusEnum attempts to convert a string to a StatusEnum.
func ParseStatusEnum(name string) (StatusEnum, error) {
	if x, ok := _StatusEnumValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _StatusEnumValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return StatusEnum(0), fmt.Errorf("%s is %w", name, ErrInvalidStatusEnum)
}

// MustParseStatusEnum converts a string to a StatusEnum, and panics if is not valid.
func MustParseStatusEnum(name string) StatusEnum {
	val, err := ParseStatusEnum(name)
	if err != nil {
		panic(err)
	}
	return val
}

// MarshalText implements the text marshaller method.
func (x StatusEnum) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *StatusEnum) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseStatusEnum(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *StatusEnum) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// WsMsgTypeEnumPING is a WsMsgTypeEnum of type PING.
	WsMsgTypeEnumPING WsMsgTypeEnum = "ping"
	// WsMsgTypeEnumPONG is a WsMsgTypeEnum of type PONG.
	WsMsgTypeEnumPONG WsMsgTypeEnum = "pong"
	// WsMsgTypeEnumJOIN is a WsMsgTypeEnum of type JOIN.
	WsMsgTypeEnumJOIN WsMsgTypeEnum = "join"
	// WsMsgTypeEnumLEAVE is a WsMsgTypeEnum of type LEAVE.
	WsMsgTypeEnumLEAVE WsMsgTypeEnum = "leave"
	// WsMsgTypeEnumFORGEROUND is a WsMsgTypeEnum of type FORGEROUND.
	WsMsgTypeEnumFORGEROUND WsMsgTypeEnum = "forgeround"
	// WsMsgTypeEnumUPGRADE is a WsMsgTypeEnum of type UPGRADE.
	WsMsgTypeEnumUPGRADE WsMsgTypeEnum = "upgrade"
)

var ErrInvalidWsMsgTypeEnum = fmt.Errorf("not a valid WsMsgTypeEnum, try [%s]", strings.Join(_WsMsgTypeEnumNames, ", "))

var _WsMsgTypeEnumNames = []string{
	string(WsMsgTypeEnumPING),
	string(WsMsgTypeEnumPONG),
	string(WsMsgTypeEnumJOIN),
	string(WsMsgTypeEnumLEAVE),
	string(WsMsgTypeEnumFORGEROUND),
	string(WsMsgTypeEnumUPGRADE),
}

// WsMsgTypeEnumNames returns a list of possible string values of WsMsgTypeEnum.
func WsMsgTypeEnumNames() []string {
	tmp := make([]string, len(_WsMsgTypeEnumNames))
	copy(tmp, _WsMsgTypeEnumNames)
	return tmp
}

// WsMsgTypeEnumValues returns a list of the values for WsMsgTypeEnum
func WsMsgTypeEnumValues() []WsMsgTypeEnum {
	return []WsMsgTypeEnum{
		WsMsgTypeEnumPING,
		WsMsgTypeEnumPONG,
		WsMsgTypeEnumJOIN,
		WsMsgTypeEnumLEAVE,
		WsMsgTypeEnumFORGEROUND,
		WsMsgTypeEnumUPGRADE,
	}
}

// String implements the Stringer interface.
func (x WsMsgTypeEnum) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x WsMsgTypeEnum) IsValid() bool {
	_, err := ParseWsMsgTypeEnum(string(x))
	return err == nil
}

var _WsMsgTypeEnumValue = map[string]WsMsgTypeEnum{
	"ping":       WsMsgTypeEnumPING,
	"pong":       WsMsgTypeEnumPONG,
	"join":       WsMsgTypeEnumJOIN,
	"leave":      WsMsgTypeEnumLEAVE,
	"forgeround": WsMsgTypeEnumFORGEROUND,
	"upgrade":    WsMsgTypeEnumUPGRADE,
}

// ParseWsMsgTypeEnum attempts to convert a string to a WsMsgTypeEnum.
func ParseWsMsgTypeEnum(name string) (WsMsgTypeEnum, error) {
	if x, ok := _WsMsgTypeEnumValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _WsMsgTypeEnumValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return WsMsgTypeEnum(""), fmt.Errorf("%s is %w", name, ErrInvalidWsMsgTypeEnum)
}

// MustParseWsMsgTypeEnum converts a string to a WsMsgTypeEnum, and panics if is not valid.
func MustParseWsMsgTypeEnum(name string) WsMsgTypeEnum {
	val, err := ParseWsMsgTypeEnum(name)
	if err != nil {
		panic(err)
	}
	return val
}

// MarshalText implements the text marshaller method.
func (x WsMsgTypeEnum) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *WsMsgTypeEnum) UnmarshalText(text []byte) error {
	tmp, err := ParseWsMsgTypeEnum(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *WsMsgTypeEnum) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}
