{% autoescape false %}/* eslint-disable */
/* istanbul ignore file */
// Code generated by api-blueprint (TypeScript); DO NOT EDIT.

export interface ApiClientConfig {
  baseUrl?: string;
  fetcher?: typeof fetch;
  defaultHeaders?: Record<string, string>;
  timeoutMs?: number;
  init?: RequestInit;
}

type RequestBody = RequestInit["body"];

function serializeQuery(params?: Record<string, unknown>): string {
  if (!params) {
    return "";
  }
  const parts: string[] = [];
  const append = (key: string, value: unknown) => {
    if (value === undefined || value === null) {
      return;
    }
    if (Array.isArray(value)) {
      value.forEach((item) => append(key, item));
      return;
    }
    const primitive =
      typeof value === "string" ||
      typeof value === "number" ||
      typeof value === "boolean";
    const encodedValue = primitive ? String(value) : JSON.stringify(value);
    parts.push(`${encodeURIComponent(key)}=${encodeURIComponent(encodedValue)}`);
  };
  Object.entries(params).forEach(([key, value]) => append(key, value));
  return parts.join("&");
}

function buildFormData(data: Record<string, unknown>): FormData {
  const form = new FormData();
  const append = (key: string, value: unknown) => {
    if (value === undefined || value === null) {
      return;
    }
    if (Array.isArray(value)) {
      value.forEach((item) => append(key, item));
      return;
    }
    if (value instanceof Blob) {
      form.append(key, value);
      return;
    }
    if (typeof File !== "undefined" && value instanceof File) {
      form.append(key, value);
      return;
    }
    if (typeof value === "object") {
      form.append(key, JSON.stringify(value));
      return;
    }
    form.append(key, String(value));
  };

  Object.entries(data ?? {}).forEach(([key, value]) => append(key, value));
  return form;
}

export interface RequestOptions<R> {
  method: string;
  path: string;
  query?: Record<string, unknown>;
  json?: unknown;
  form?: Record<string, unknown>;
  body?: RequestBody;
  headers?: Record<string, string>;
  init?: RequestInit;
  responseType?: "json" | "text";
  timeoutMs?: number;
}

const defaultFetch: typeof fetch = (...args) => fetch(...args);

export class BaseClient {
  protected readonly baseUrl: string;
  protected readonly fetcher: typeof fetch;
  protected readonly timeoutMs?: number;

  constructor(protected readonly config: ApiClientConfig = {}, defaultBaseUrl: string = "") {
    this.baseUrl = config.baseUrl ?? defaultBaseUrl;
    this.fetcher = config.fetcher ?? defaultFetch;
    this.timeoutMs = config.timeoutMs;
  }

  protected mergeHeaders(extra?: Record<string, string>): Record<string, string> {
    return {
      ...(this.config.defaultHeaders ?? {}),
      ...(extra ?? {}),
    };
  }

  protected buildUrl(path: string, query?: Record<string, unknown>): string {
    const base = (this.baseUrl || "").replace(/\/$/, "");
    const normalizedPath = path.startsWith("/") ? path : `/${path}`;
    const url = base ? `${base}${normalizedPath}` : normalizedPath;
    const queryString = serializeQuery(query);
    return queryString ? `${url}?${queryString}` : url;
  }

  protected buildWsUrl(path: string, query?: Record<string, unknown>): string {
    const httpUrl = this.buildUrl(path, query);
    if (httpUrl.startsWith("http://") || httpUrl.startsWith("https://")) {
      return httpUrl.replace(/^http/, "ws");
    }
    const origin =
      this.baseUrl ||
      (typeof window !== "undefined" ? window.location.origin : "http://localhost");
    const absolute = origin.replace(/\/$/, "") + (httpUrl.startsWith("/") ? httpUrl : `/${httpUrl}`);
    return absolute.replace(/^http/, "ws");
  }

  protected async request<R>({
    method,
    path,
    query,
    json,
    form,
    body: rawBody,
    headers: extraHeaders,
    init,
    responseType = "json",
    timeoutMs,
  }: RequestOptions<R>): Promise<R> {
    const url = this.buildUrl(path, query);
    const headers = this.mergeHeaders(extraHeaders);

    const mergedInit: RequestInit = {
      ...(this.config.init ?? {}),
      ...(init ?? {}),
    };

    let body: RequestBody | undefined = mergedInit.body ?? rawBody;

    if (json !== undefined) {
      body = JSON.stringify(json);
      headers["Content-Type"] = headers["Content-Type"] ?? "application/json";
    } else if (form !== undefined) {
      body = buildFormData(form);
    }

    const effectiveTimeoutMs = timeoutMs ?? this.timeoutMs;

    let controller: AbortController | undefined;
    let timeoutId: ReturnType<typeof setTimeout> | undefined;
    let signal: AbortSignal | undefined;

    if (effectiveTimeoutMs != null) {
      controller = new AbortController();

      if (mergedInit.signal) {
        const externalSignal = mergedInit.signal;
        if (externalSignal.aborted) {
          controller.abort();
        } else {
          externalSignal.addEventListener(
            "abort",
            () => controller?.abort(),
            { once: true },
          );
        }
      }

      timeoutId = setTimeout(() => {
        controller?.abort();
      }, effectiveTimeoutMs);

      signal = controller.signal;
    } else if (mergedInit.signal) {
      signal = mergedInit.signal;
    }

    const response = await this.fetcher(
      url,
      {
        ...mergedInit,
        method,
        headers,
        body,
        signal,
      },
    );

    if (!response.ok) {
      throw new Error(`Request failed: ${response.status} ${response.statusText}`);
    }

    if (responseType === "text") {
      return (await response.text()) as unknown as R;
    }
    if (response.status === 204) {
      return undefined as R;
    }
    return (await response.json()) as R;
  }

  protected connect(path: string, query?: Record<string, unknown>, protocols?: string | string[]): WebSocket {
    const wsUrl = this.buildWsUrl(path, query);
    return new WebSocket(wsUrl, protocols);
  }
}
{% endautoescape %}
