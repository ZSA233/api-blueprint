// Code generated by api-blueprint (Golang); DO NOT EDIT.

package {{ writer.provider_package }}

{% set ns = namespace(imports=['"net/http"']) %}

{% set gen_proto_block %}
{% set fmts = writer.formatters() %}

// ============================= JSON ================================
{% set rsp_json_wrappers = writer.response_wrappers('RSP_JSON') | list %}
{% for wrapper in rsp_json_wrappers %}
	{% set proto = wrapper.proto %}
	{% for imp in proto.import_specs(fmts) %}
		{% if imp %}
			{% set ns.imports = ns.imports + [imp] %}
		{% endif %}
	{% endfor %}
	{% if wrapper.proto_type == 'struct' %}
		{% for field in proto.fields() %}
			{% set imps = field.import_specs(fmts) %}
			{% if imps %}
				{% set ns.imports = ns.imports + imps %}
			{% endif %}
		{% endfor %}
	type {{ wrapper.proto_def_name }} struct {
		{% for field in wrapper.proto_fields_for(fmts) %}{{ field.name }} {{ field.type | safe }} `{{ field.tags | safe }}`
		{% endfor %}
	}
	{% elif wrapper.proto_type == 'generic' %}
	type {{ wrapper.proto_def_name }} = {{ proto.generic.type_reference(fmts) }}[
		{% for typ in proto.generics(fmts) %}{{ typ | safe}},
		{% endfor %}
	]
	{% elif wrapper.proto_type == 'alias' %}
	type {{ wrapper.proto_def_name }} {% if not proto.alias.new_type %}={% endif %} {{ proto.alias.type_reference(fmts) | safe }}
	{% endif %}
{% endfor %}


{% for wrapper in rsp_json_wrappers %}
	{% set proto = wrapper.proto %}
	func NewRSP_JSON_{{ wrapper.class_name }}[Q, B, P any](prov *RspProvider[Q, B, P], data *P, err error) (codeInt int, rsp any) {
		code, message := unwrapError(err)
		_, _ = code, message
		{{ 
			wrapper.json_factory(
				wrapper_name=wrapper.proto_name,
				generic_types='[P]',
				code='code', 
				data='data', 
				message='message',
			) | safe
		}}
	}
{% endfor %}


func NewRSP_JSON_Entry[Q, B, P any](prov *RspProvider[Q, B, P], data *P, err error) (code int, rsp any) {
	switch prov.Options {
	{% for wrapper in rsp_json_wrappers %}
	case "{{ wrapper.class_name }}":
		code, rsp = NewRSP_JSON_{{ wrapper.class_name }}(prov, data, err){% endfor %}
	default:
		panic("[NewRS_JSON] should unreachable.")
	}
	return
}


{% set rsp_xml_wrappers = writer.response_wrappers('RSP_XML') | list %}
{% if rsp_xml_wrappers | length > 0 %}
// ============================= XML ================================
type RSP_XML[P any] struct {
	XMLName xml.Name
	Inner   *P
}
{% set ns.imports = ns.imports + ['"encoding/xml"'] %}{% endif %}
{% for wrapper in rsp_xml_wrappers %}
	{% set proto = wrapper.proto %}
	{% for imps in proto.import_specs(fmts) %}
		{% if imps %}
			{% set ns.imports = ns.imports + imps %}
		{% endif %}
	{% endfor %}
	{% if wrapper.proto_type == 'struct' %}
		{% for field in proto.fields() %}
			{% set imps = field.import_specs(fmts) %}
			{% if imps %}
				{% set ns.imports = ns.imports + imps %}
			{% endif %}
		{% endfor %}
	type {{ wrapper.proto_name }}_INNER{{ wrapper.generic_types(True) }} struct {
		{% for field in wrapper.proto_fields_for(fmts) %}{{ field.name }} {{ field.type | safe }} `{{ field.tags | safe }}`
		{% endfor %}
	}
	{% elif wrapper.proto_type == 'generic' %}
	type {{ wrapper.proto_name }}_INNER{{ wrapper.generic_types(True) }} = {{ proto.generic.type_reference(fmts) }}[
		{% for typ in proto.generics(fmts) %}{{ typ | safe}},
		{% endfor %}
	]
	{% elif wrapper.proto_type == 'alias' %}
	type {{ wrapper.proto_name }}_INNER{{ wrapper.generic_types(True) }} {% if not proto.alias.new_type %}={% endif %} {{ proto.alias.type_reference(fmts) | safe }}
	{% endif %}

	type {{ wrapper.proto_def_name }} RSP_XML[{{ wrapper.proto_name }}_INNER{{ wrapper.generic_types() }}]

	func (r {{ wrapper.proto_name ~ wrapper.generic_types() }}) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
		return marshalXML(enc, start, r.XMLName, r.Inner)
	}
{% endfor %}


{% for wrapper in rsp_xml_wrappers %}
	func NewRSP_XML_{{ wrapper.class_name }}[Q, B, P any](prov *RspProvider[Q, B, P], data *P, err error) (codeInt int, rsp any) {
		code, message := unwrapError(err)
		_, _ = code, message
		{{ 
			wrapper.xml_factory(
				wrapper_name=wrapper.proto_name,
				generic_types='[P]',
				code='code', 
				data='data', 
				message='message',
			) | safe
		}}
	}
{% endfor %}

func NewRSP_XML_Entry[Q, B, P any](prov *RspProvider[Q, B, P], data *P, err error) (code int, rsp any) {
	switch prov.Options {
	{% for wrapper in rsp_xml_wrappers %}
	case "{{ wrapper.class_name }}":
		code, rsp = NewRSP_XML_{{ wrapper.class_name }}(prov, data, err){% endfor %}
	default:
		panic("[NewRSP_XML] should unreachable.")
	}
	return
}

{% endset %}



import (
	{% for imp in ns.imports | unique | list %}{{ imp | safe }}
	{% endfor %}
)

var (
	_ = http.StatusBadRequest
)


type REQ[Q, B any] struct {
	Q *Q
	B *B
}


{{ gen_proto_block }}
