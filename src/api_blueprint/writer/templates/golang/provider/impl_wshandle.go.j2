package provider


{% if 'ws_handle' in writer.list_providers() %}
import (
	"context"
	"net/http"

	"github.com/coder/websocket"
	"github.com/coder/websocket/wsjson"
)

type WsHandleContext[Q, B, P any] struct {
	Conn     *websocket.Conn
	Response *P
	Error    error
}

func (prov *WsHandleProvider[Q, B, P]) Handle(anyCtx ContextInterface) {
	ctx := AdaptContext[Q, B, P](anyCtx)
	var err error

	if ctx.Req == nil {
		_ = ctx.Gin.AbortWithError(http.StatusBadRequest, err)
		return
	}

	req, err := ctx.Req.Request, ctx.Req.Error
	if err != nil {
		_ = ctx.Gin.AbortWithError(http.StatusBadRequest, err)
		return
	}
	opts := &websocket.AcceptOptions{
		Subprotocols:    prov.Subs,
		CompressionMode: websocket.CompressionContextTakeover,
		// InsecureSkipVerify: true,
	}

	conn, err := websocket.Accept(
		ctx.Gin.Writer,
		ctx.Gin.Request,
		opts,
	)
	if err != nil {
		_ = ctx.Gin.AbortWithError(http.StatusBadRequest, err)
		return
	}
	if conn.Subprotocol() == "" {
		conn.Close(websocket.StatusPolicyViolation, "subprotocol required")
		return
	}
	defer conn.CloseNow()

	ctx.WsHandle = &WsHandleContext[Q, B, P]{
		Conn: conn,
	}

	var rsp *P
	rsp, err = prov.Handler(ctx, req)
	ctx.WsHandle.Response = rsp
	ctx.WsHandle.Error = err
	if err != nil {
		conn.Close(websocket.StatusInternalError, err.Error())
	} else {
		conn.Close(websocket.StatusNormalClosure, "")
	}
	// 在ws中，忽略更深层的中间件
}

func WsJSONReadLoop[MSG any](conn *websocket.Conn, fn func(msg *MSG, err error) (stopped bool), cs ...context.Context) (err error) {
	if conn == nil {
		return nil
	}
	var c context.Context
	if len(cs) > 0 {
		c = cs[0]
	} else {
		c = context.Background()
	}
	for {
		msg := new(MSG)
		err = wsjson.Read(c, conn, msg)
		if fn(msg, err) {
			break
		}

	}
	return
}


{% else %}


type WsHandleContext[Q, B, P any] struct {
	Conn     any
	Response *P
	Error    error
}

func (prov *WsHandleProvider[Q, B, P]) Handle(anyCtx ContextInterface) {
	panic("unreachable")
}

{% endif %}