// Code generated by api-blueprint (Golang); DO NOT EDIT.

package {{ writer.provider_package }}

import (
	"strings"
)

const (
	PROV_REQ = "req"
)

type ReqProvider[Q, B, P any] struct {
	Data      string
	BindQuery bool
	BindJSON  bool
	BindForm  bool
}

func NewReqProvider[Q, B, P any](
	data string,
	handler func(c *Context[Q, B, P], req *REQ[Q, B]) (rsp *P, err error),
) *ReqProvider[Q, B, P] {
	var bindQuery, bindJSON, bindForm bool
	if strings.Contains(data, "Q") {
		bindQuery = true
	}
	if strings.Contains(data, "J") {
		bindJSON = true
	}
	if strings.Contains(data, "F") {
		bindForm = true
	}
	return &ReqProvider[Q, B, P]{
		Data:      data,
		BindQuery: bindQuery,
		BindJSON:  bindJSON,
		BindForm:  bindForm,
	}
}

func (prov *ReqProvider[Q, B, P]) GetName() string {
	return PROV_REQ
}

func (prov *ReqProvider[Q, B, P]) makeReq(ctx *Context[Q, B, P]) (*REQ[Q, B], error) {
	var reqQ *Q
	var reqB *B

	var err error

	if prov.BindQuery {
		reqQ = new(Q)
		if err = ctx.Gin.ShouldBindQuery(reqQ); err != nil {
			return nil, err
		}
	}
	
	if prov.BindJSON {
		reqB = new(B)
		if err = ctx.Gin.ShouldBindJSON(reqB); err != nil {
			return nil, err
		}
	} else if prov.BindForm {
		reqB = new(B)
		if err = ctx.Gin.ShouldBind(reqB); err != nil {
			return nil, err
		}
	}

	var req = &REQ[Q, B]{
		Q: reqQ,
		B: reqB,
	}
	return req, nil
}
