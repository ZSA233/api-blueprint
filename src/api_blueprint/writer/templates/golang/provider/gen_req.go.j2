// Code generated by api-gen-golang; DO NOT EDIT.

package {{ writer.provider_package }}

import (
	"strings"
)

const (
	PROV_REQ = "req"
)

type ReqProvider[Q, F, J, P any] struct {
	Data      string
	BindQuery bool
	BindJSON  bool
	BindForm  bool
}

func NewReqProvider[Q, F, J, P any](
	data string,
	handler func(c *Context[Q, F, J, P], req *REQ[Q, F, J]) (rsp *P, err error),
) *ReqProvider[Q, F, J, P] {
	var bindQuery, bindJSON, bindForm bool
	if strings.Contains(data, "Q") {
		bindQuery = true
	}
	if strings.Contains(data, "J") {
		bindJSON = true
	}
	if strings.Contains(data, "F") {
		bindForm = true
	}
	return &ReqProvider[Q, F, J, P]{
		Data:      data,
		BindQuery: bindQuery,
		BindJSON:  bindJSON,
		BindForm:  bindForm,
	}
}

func (prov *ReqProvider[Q, F, J, P]) GetName() string {
	return PROV_REQ
}

func (prov *ReqProvider[Q, F, J, P]) makeReq(ctx *Context[Q, F, J, P]) (*REQ[Q, F, J], error) {
	var reqQ *Q
	var reqJ *J
	var reqF *F

	var err error

	if prov.BindQuery {
		reqQ = new(Q)
		if err = ctx.Gin.ShouldBindQuery(reqQ); err != nil {
			return nil, err
		}
	}
	if prov.BindJSON {
		reqJ = new(J)
		if err = ctx.Gin.ShouldBindJSON(reqJ); err != nil {
			return nil, err
		}
	}
	if prov.BindForm {
		reqF = new(F)
		if err = ctx.Gin.ShouldBind(reqF); err != nil {
			return nil, err
		}
	}

	var req = &REQ[Q, F, J]{
		Q: reqQ,
		J: reqJ,
		F: reqF,
	}
	return req, nil
}
